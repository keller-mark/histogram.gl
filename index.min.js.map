{"version":3,"file":"index.min.js","sources":["../src/utils.js","../src/index.js","../src/demo/index.js"],"sourcesContent":["\n// Reference: https://github.com/lodash/lodash/blob/86a852fe763935bb64c12589df5391fd7d3bb14d/.internal/baseRange.js#L12\nfunction baseRange(start, end, step, fromRight) {\n    let index = -1\n    let length = Math.max(Math.ceil((end - start) / (step || 1)), 0)\n    const result = new Array(length)\n  \n    while (length--) {\n      result[fromRight ? length : ++index] = start\n      start += step\n    }\n    return result\n}\n\n// Reference: https://github.com/lodash/lodash/blob/86a852fe763935bb64c12589df5391fd7d3bb14d/toFinite.js#L28\nfunction toFinite(value) {\n    if (!value) {\n      return value === 0 ? value : 0\n    }\n    return value === value ? value : 0\n}\n\nexport function range(start, end, step) {\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite(start)\n    if (end === undefined) {\n      end = start\n      start = 0\n    } else {\n      end = toFinite(end)\n    }\n    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step)\n    return baseRange(start, end, step, false)\n}\n\n// Reference: https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html\nexport function createShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success) {\n      return shader;\n    }\n  \n    console.log(gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n}\n\n// Reference: https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html\nexport function createProgram(gl, vertexShader, fragmentShader) {\n    var program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (success) {\n      return program;\n    }\n  \n    console.log(gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n}","import { vs, fs } from './shaders';\nimport { range, createShader, createProgram } from './utils';\nconst TARGET_TEXTURE_WIDTH = 256;\nconst TARGET_TEXTURE_HEIGHT = 1;\n\nexport function createRgbaHistogram(rgbaData, imageWidth, imageHeight) {\n\n    return new Promise((resolve, reject) => {\n        // TODO: use OffscreenCanvas when available in firefox.\n\n        // Create canvas.\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = TARGET_TEXTURE_WIDTH;\n        canvas.height = TARGET_TEXTURE_HEIGHT;\n\n        // Get WebGL context.\n        const gl = canvas.getContext(\"webgl\");\n\n        const exts = [\"OES_texture_float\", \"EXT_float_blend\", \"EXT_color_buffer_float\", \"WEBGL_color_buffer_float\"];\n\n        exts.forEach((extName) => {\n            let ext = gl.getExtension(extName);\n            if (!ext) {\n                console.warn(`histogram.gl did not find the ${extName} WebGL extension.`);\n            }\n        });\n\n        const pixelIds = Float32Array.from(range(imageWidth * imageHeight));\n\n        const imageTexture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, imageTexture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, imageWidth, imageHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n\n        // Create GLSL shaders, upload the GLSL source, compile the shaders.\n        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vs);\n        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fs);\n\n        // Link the two shaders into a program.\n        const program = createProgram(gl, vertexShader, fragmentShader);\n        \n        // Create the pixelIds buffer from the pixelIds array.\n        const pixelIdsBuffer = gl.createBuffer();\n        // Bind the buffer.\n        gl.bindBuffer(gl.ARRAY_BUFFER, pixelIdsBuffer);\n        // Pass the data to the bound buffer.\n        gl.bufferData(gl.ARRAY_BUFFER, pixelIds, gl.STATIC_DRAW);\n\n        // Create texture to render to.\n        const targetTexture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, TARGET_TEXTURE_WIDTH, TARGET_TEXTURE_HEIGHT, 0, gl.RGBA, gl.FLOAT, null);\n\n\n        // Create frame buffer target.\n        const targetFramebuffer = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, targetFramebuffer);\n\n        const attachmentPoint = gl.COLOR_ATTACHMENT0;\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, 0);\n\n\n        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n            reject(new Error(\"can't render to floating point texture\"));\n        }\n\n        // Render sum of each color\n\n        // we're going to render a gl.POINT for each pixel in the source image\n        // That point will be positioned based on the color of the source image\n        // we're just going to render vec4(1,1,1,1). This blend function will\n        // mean each time we render to a specific point that point will get\n        // incremented by 1.\n        gl.blendEquation(gl.FUNC_ADD);\n        gl.blendFunc(gl.ONE, gl.ONE);\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.disable(gl.DEPTH_TEST);\n        gl.enable(gl.BLEND);\n        gl.useProgram(program);\n        \n\n        // Look up where the vertex data needs to go.\n        const pixelIdsAttributeLocation = gl.getAttribLocation(program, \"pixelId\");\n        // Turn on the attribute.\n        gl.enableVertexAttribArray(pixelIdsAttributeLocation);\n        // Tell the attribute how to get data out of the buffer (ARRAY_BUFFER).\n        gl.vertexAttribPointer(pixelIdsAttributeLocation, 1, gl.FLOAT, false, 0, 0);\n\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, targetFramebuffer);\n        gl.viewport(0, 0, TARGET_TEXTURE_WIDTH, TARGET_TEXTURE_HEIGHT);\n\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        // render each channel separately since we can only position each POINT\n        // for one channel at a time.\n        let unit = 0;\n        for (var channel = 0; channel < 4; ++channel) {\n            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n            \n            const resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n            gl.uniform2fv(resolutionLocation, [imageWidth, imageHeight]);\n\n            const colorMultLocation = gl.getUniformLocation(program, \"u_colorMult\");\n            gl.uniform4fv(colorMultLocation, [\n                channel === 0 ? 1 : 0,\n                channel === 1 ? 1 : 0,\n                channel === 2 ? 1 : 0,\n                channel === 3 ? 1 : 0,\n            ]);\n\n            const imageTextureLocation = gl.getUniformLocation(program, \"u_texture\");\n            \n            gl.activeTexture(gl.TEXTURE0 + unit);\n            gl.bindTexture(gl.TEXTURE_2D, imageTexture);\n            gl.uniform1i(imageTextureLocation, unit++);\n\n            gl.drawArrays(gl.POINTS, 0, pixelIds.length);\n            // Flush the buffer just to be sure everything is rendered to the texture.\n            gl.flush();\n        }\n\n        const histogramData = new Float32Array(TARGET_TEXTURE_WIDTH * TARGET_TEXTURE_HEIGHT * 4);\n        gl.readPixels(0, 0, TARGET_TEXTURE_WIDTH, TARGET_TEXTURE_HEIGHT, gl.RGBA, gl.FLOAT, histogramData);\n        resolve(histogramData);\n    });\n}","import { createRgbaHistogram } from '../index';\nimport './index.scss';\n\nconst imageUrl = \"https://gist.githubusercontent.com/mbostock/9511ae067889eefa5537eedcbbf87dab/raw/944b6e5fe8dd535d6381b93d88bf4a854dac53d4/mona-lisa.jpg\";\n\n// Reference: https://observablehq.com/@mbostock/image-histogram/2\nfunction getImageData(image, width = image.naturalWidth, height = image.naturalHeight) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    \n    const context = canvas.getContext(\"2d\");\n    context.drawImage(image, 0, 0, width, height);\n    const imageData = context.getImageData(0, 0, width, height).data;\n    return imageData;\n}\n\nfunction getChannelData(imageData, offset = 0, float = false) {\n    const channelData = (float ? new Float32Array(imageData.length / 4) : new Uint8Array(imageData.length / 4));\n    for(let i = 0; i < channelData.length; i++) {\n      channelData[i] = imageData[i * 4 + offset];\n    }\n    return channelData;\n}\n\n\nnew Promise((resolve, reject) => {\n    const image = new Image;\n    image.onload = () => resolve(image);\n    image.onerror = reject;\n    image.crossOrigin = \"anonymous\";\n    image.src = imageUrl;\n})\n.then((image) => {\n    console.log(image);\n    // Get the image data Uint8ClampedArray from the image object.\n    const imageData = getImageData(image);\n    // Get the red channel.\n    const channelData = getChannelData(imageData, 0);\n    return createRgbaHistogram(imageData, image.naturalWidth, image.naturalHeight);\n})\n.then((histogramData) => {\n    console.log(\"Histogram Data\");\n    console.log(histogramData);\n\n    const mlImage = document.createElement(\"img\");\n    mlImage.crossOrigin = true;\n    mlImage.src = imageUrl;\n    mlImage.width = 200;\n    document.querySelector(\"#root\").appendChild(mlImage);\n\n    const header = document.createElement(\"h2\");\n    header.innerHTML = \"histogram.gl result\";\n    document.querySelector(\"#root\").appendChild(header);\n\n\n    const canvas = document.createElement(\"canvas\");\n    document.querySelector(\"#root\").appendChild(canvas);\n\n    canvas.width = 400;\n    canvas.height = 200;\n\n    const ctx = canvas.getContext(\"2d\");\n    // Turn transparency on\n    ctx.globalAlpha = 0.4;\n\n    const channels = [\"red\", \"green\", \"blue\"];\n\n    channels.forEach((channel, channelOffset) => {\n        const channelHistogramData = Array.from(getChannelData(histogramData, channelOffset, true));\n        const channelHistogramMax = Math.max(...channelHistogramData);\n\n        channelHistogramData.forEach((d, i) => {\n            const height = (d / channelHistogramMax) * canvas.height;\n            const x = i / 256 * canvas.width;\n            ctx.beginPath();\n            ctx.rect(x, canvas.height - height, 1 / 256 * canvas.width, canvas.height);\n            ctx.fillStyle = channel;\n            ctx.fill();\n        });\n    });\n\n    const header2 = document.createElement(\"h2\");\n    header2.innerHTML = \"ground truth\";\n    document.querySelector(\"#root\").appendChild(header2);\n\n    const gtImage = document.createElement(\"img\");\n    gtImage.crossOrigin = true;\n    gtImage.src = \"https://raw.githubusercontent.com/keller-mark/histogram.gl/master/screenshot.png\";\n    document.querySelector(\"#root\").appendChild(gtImage);\n\n    \n});\n\n"],"names":["toFinite","value","range","start","end","step","undefined","fromRight","index","length","Math","max","ceil","result","Array","baseRange","createShader","gl","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","createRgbaHistogram","rgbaData","imageWidth","imageHeight","Promise","resolve","reject","canvas","document","createElement","width","height","getContext","forEach","extName","getExtension","warn","pixelIds","Float32Array","from","imageTexture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","pixelIdsBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","targetTexture","FLOAT","targetFramebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","attachmentPoint","COLOR_ATTACHMENT0","framebufferTexture2D","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","Error","blendEquation","FUNC_ADD","blendFunc","ONE","clearColor","disable","DEPTH_TEST","enable","BLEND","useProgram","pixelIdsAttributeLocation","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","viewport","clear","COLOR_BUFFER_BIT","unit","channel","colorMask","resolutionLocation","getUniformLocation","uniform2fv","colorMultLocation","uniform4fv","imageTextureLocation","activeTexture","TEXTURE0","uniform1i","drawArrays","POINTS","flush","histogramData","TARGET_TEXTURE_WIDTH","readPixels","imageUrl","getChannelData","imageData","offset","float","channelData","Uint8Array","i","image","Image","onload","onerror","crossOrigin","src","then","naturalWidth","naturalHeight","context","drawImage","getImageData","data","mlImage","querySelector","appendChild","header","innerHTML","ctx","globalAlpha","channelOffset","channelHistogramData","channelHistogramMax","d","x","beginPath","rect","fillStyle","fill","header2","gtImage"],"mappings":"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"}