{"version":3,"file":"index.min.js","sources":["../src/shaders.js","../src/utils.js","../src/index.js","../src/demo/index.js"],"sourcesContent":["export const rgba = {\n    vs: `\n    attribute float a_pixel_id;\n    \n    uniform vec2 u_resolution;\n    uniform sampler2D u_texture;\n    uniform vec4 u_color_mult;\n    \n    void main() {\n        // Compute the pixel (x, y) for the source image based on a pixel index.\n        vec2 pixel = vec2(mod(a_pixel_id, u_resolution.x), floor(a_pixel_id / u_resolution.x));\n        \n        // Compute center of the pixel.\n        vec2 uv = (pixel + 0.5) / u_resolution;\n        \n        // Get the color but zero out 3 of the 4 channels.\n        vec4 color = texture2D(u_texture, uv) * u_color_mult;\n        \n        // Add the channels.\n        float color_sum = color.r + color.g + color.b + color.a;\n        \n        // Set the position to somewhere in the 256x1 target texture.\n        gl_Position = vec4((color_sum * 255.0 + 0.5) / 256.0 * 2.0 - 1.0, 0.5, 0, 1);\n        gl_PointSize = 1.0;\n    }\n    `,\n    fs: `\n    precision highp float;\n    \n    void main() {\n        gl_FragColor = vec4(1);\n    }\n    `,\n};\n\nexport const singleChannel = {\n    vs: `\n    attribute float a_pixel_id;\n    \n    uniform vec2 u_resolution;\n    uniform sampler2D u_texture;\n    \n    void main() {\n        // Compute the pixel (x, y) for the source image based on a pixel index.\n        vec2 pixel = vec2(mod(a_pixel_id, u_resolution.x), floor(a_pixel_id / u_resolution.x));\n        \n        // Compute center of the pixel.\n        vec2 uv = (pixel + 0.5) / u_resolution;\n        \n        // Get the color of interest.\n        float color = texture2D(u_texture, uv).r;\n        \n        // Set the position to somewhere in the 256x1 target texture.\n        gl_Position = vec4((color * 255.0 + 0.5) / 256.0 * 2.0 - 1.0, 0.5, 0, 1);\n        gl_PointSize = 1.0;\n    }\n    `,\n    fs: `\n    precision highp float;\n    \n    void main() {\n        gl_FragColor = vec4(1);\n    }\n    `,\n};","\n// Reference: https://github.com/lodash/lodash/blob/86a852fe763935bb64c12589df5391fd7d3bb14d/.internal/baseRange.js#L12\nfunction baseRange(start, end, step, fromRight) {\n    let index = -1\n    let length = Math.max(Math.ceil((end - start) / (step || 1)), 0)\n    const result = new Array(length)\n  \n    while (length--) {\n      result[fromRight ? length : ++index] = start\n      start += step\n    }\n    return result\n}\n\n// Reference: https://github.com/lodash/lodash/blob/86a852fe763935bb64c12589df5391fd7d3bb14d/toFinite.js#L28\nfunction toFinite(value) {\n    if (!value) {\n      return value === 0 ? value : 0\n    }\n    return value === value ? value : 0\n}\n\nexport function range(start, end, step) {\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite(start)\n    if (end === undefined) {\n      end = start\n      start = 0\n    } else {\n      end = toFinite(end)\n    }\n    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step)\n    return baseRange(start, end, step, false)\n}\n\n// Reference: https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html\nexport function createShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n    if (success) {\n      return shader;\n    }\n  \n    console.log(gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n}\n\n// Reference: https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html\nexport function createProgram(gl, vertexShader, fragmentShader) {\n    var program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (success) {\n      return program;\n    }\n  \n    console.log(gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n}","import { rgba, singleChannel } from './shaders';\nimport { range, createShader, createProgram } from './utils';\n\nconst TARGET_TEXTURE_WIDTH = 256;\nconst TARGET_TEXTURE_HEIGHT = 1;\n\nfunction getChannelData(imageData, offset = 0) {\n    const channelData = new Float32Array(imageData.length / 4);\n    for(let i = 0; i < channelData.length; i++) {\n      channelData[i] = imageData[i * 4 + offset];\n    }\n    return channelData;\n}\n\nfunction createHistogram(imageData, imageWidth, imageHeight, isRgba) {\n    return new Promise((resolve, reject) => {\n        // TODO: use OffscreenCanvas when available in firefox.\n\n        // Create a canvas.\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = TARGET_TEXTURE_WIDTH;\n        canvas.height = TARGET_TEXTURE_HEIGHT;\n\n        // Get the WebGL context.\n        const gl = canvas.getContext(\"webgl\");\n\n        // TODO: check these against the supported extensions to throw better warnings.\n        const exts = [\"OES_texture_float\", \"EXT_float_blend\", \"EXT_color_buffer_float\", \"WEBGL_color_buffer_float\"];\n\n        exts.forEach((extName) => {\n            let ext = gl.getExtension(extName);\n            if (!ext) {\n                console.warn(`histogram.gl did not find the ${extName} WebGL extension.`);\n            }\n        });\n\n        // Create an array of pixel indices.\n        const pixelIds = Float32Array.from(range(imageWidth * imageHeight));\n\n        // Convert the input image to a texture.\n        const imageTexture = gl.createTexture();\n        const imageTextureFormat = (isRgba ? gl.RGBA : gl.LUMINANCE);\n        gl.bindTexture(gl.TEXTURE_2D, imageTexture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texImage2D(gl.TEXTURE_2D, 0, imageTextureFormat, imageWidth, imageHeight, 0, imageTextureFormat, gl.UNSIGNED_BYTE, imageData);\n\n        // Create GLSL shaders, upload the GLSL source, compile the shaders.\n        const shaderSources = (isRgba ? rgba : singleChannel);\n        const vertexShader = createShader(gl, gl.VERTEX_SHADER, shaderSources.vs);\n        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, shaderSources.fs);\n\n        // Link the two shaders into a program.\n        const program = createProgram(gl, vertexShader, fragmentShader);\n        \n        // Create the pixelIds buffer from the pixelIds array.\n        const pixelIdsBuffer = gl.createBuffer();\n        // Bind the buffer for pixel indices.\n        gl.bindBuffer(gl.ARRAY_BUFFER, pixelIdsBuffer);\n        // Pass the data to the bound buffer.\n        gl.bufferData(gl.ARRAY_BUFFER, pixelIds, gl.STATIC_DRAW);\n\n        // Create target texture that the framebuffer will render into.\n        const targetTexture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, TARGET_TEXTURE_WIDTH, TARGET_TEXTURE_HEIGHT, 0, gl.RGBA, gl.FLOAT, null);\n\n\n        // Create and bind a framebuffer.\n        const targetFramebuffer = gl.createFramebuffer();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, targetFramebuffer);\n\n        const attachmentPoint = gl.COLOR_ATTACHMENT0;\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, 0);\n\n\n        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n            reject(new Error(\"can't render to floating point texture\"));\n        }\n\n        gl.blendEquation(gl.FUNC_ADD);\n        gl.blendFunc(gl.ONE, gl.ONE);\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.disable(gl.DEPTH_TEST);\n        gl.enable(gl.BLEND);\n        gl.useProgram(program);\n        \n\n        // Look up where the vertex data needs to go.\n        const pixelIdsAttributeLocation = gl.getAttribLocation(program, \"a_pixel_id\");\n        // Turn on the attribute.\n        gl.enableVertexAttribArray(pixelIdsAttributeLocation);\n        // Tell the attribute how to get data out of the buffer (ARRAY_BUFFER).\n        gl.vertexAttribPointer(pixelIdsAttributeLocation, 1, gl.FLOAT, false, 0, 0);\n\n        // With our framebuffer bound, anytime we call gl.clear, gl.drawArrays, or gl.drawElements,\n        // WebGL will render to our texture instead of the canvas.\n        gl.bindFramebuffer(gl.FRAMEBUFFER, targetFramebuffer);\n        // Tell WebGL how to convert from clip space to pixels.\n        // It's extremely important to remember to call gl.viewport\n        // and set it to the size of the thing your rendering to.\n        // In this case the first time we're rendering to the texture\n        // so we set the viewport to cover the texture.\n        gl.viewport(0, 0, TARGET_TEXTURE_WIDTH, TARGET_TEXTURE_HEIGHT);\n        // Clear the framebuffer.\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        // Render each channel separately since each POINT\n        // can only be positioned for one channel at a time.\n        let unit = 0;\n        // Only render for one channel if not RGBA input.\n        const numChannels = (isRgba ? 4 : 1);\n        for (let channel = 0; channel < numChannels; ++channel) {\n            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n            \n            // Define and store the uniform data.\n            const resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n            gl.uniform2fv(resolutionLocation, [imageWidth, imageHeight]);\n\n            if(isRgba) {\n                const colorMultLocation = gl.getUniformLocation(program, \"u_color_mult\");\n                gl.uniform4fv(colorMultLocation, [\n                    channel === 0 ? 1 : 0,\n                    channel === 1 ? 1 : 0,\n                    channel === 2 ? 1 : 0,\n                    channel === 3 ? 1 : 0,\n                ]);\n            }\n\n            const imageTextureLocation = gl.getUniformLocation(program, \"u_texture\");\n            gl.activeTexture(gl.TEXTURE0 + unit);\n            gl.bindTexture(gl.TEXTURE_2D, imageTexture);\n            gl.uniform1i(imageTextureLocation, unit++);\n\n            // Draw.\n            gl.drawArrays(gl.POINTS, 0, pixelIds.length);\n\n            // Flush the buffer to be sure everything is rendered to the texture.\n            gl.flush();\n        }\n\n        // Reference: https://github.com/tensorflow/tfjs/blob/5e28965/tfjs-backend-webgl/src/gpgpu_util.ts#L304\n        let histogramData = new Float32Array(TARGET_TEXTURE_WIDTH * TARGET_TEXTURE_HEIGHT * 4);\n        gl.readPixels(0, 0, TARGET_TEXTURE_WIDTH, TARGET_TEXTURE_HEIGHT, gl.RGBA, gl.FLOAT, histogramData);\n\n        if(!isRgba) {\n            histogramData = getChannelData(histogramData, 0);\n        }\n\n        resolve(histogramData);\n    });\n}\n\n/**\n * Compute histogram values for a 4-channel (RGBA) image.\n * @param {Uint8Array} rgbaData The image data.\n * @param {number} imageWidth Image width (between 0 and 4096).\n * @param {number} imageHeight Image height (between 0 and 4096).\n * @returns {Float32Array} A 1024-element histogram array where\n * channel results are interleaved [r0, g0, b0, a0, r1, g1, b1, a1, ...]\n */\nexport function createRgbaHistogram(rgbaData, imageWidth, imageHeight) {\n    return createHistogram(rgbaData, imageWidth, imageHeight, true);\n}\n\n/**\n * Compute histogram values for a single-channel image.\n * @param {Uint8Array} channelData The channel data.\n * @param {number} imageWidth Image width (between 0 and 4096).\n * @param {number} imageHeight Image height (between 0 and 4096).\n * @returns {Float32Array} A 256-element histogram array.\n */\nexport function createSingleChannelHistogram(channelData, imageWidth, imageHeight) {\n    return createHistogram(channelData, imageWidth, imageHeight, false);\n}","import { createRgbaHistogram, createSingleChannelHistogram } from '../index';\nimport './index.scss';\n\nconst imageUrl = \"https://gist.githubusercontent.com/mbostock/9511ae067889eefa5537eedcbbf87dab/raw/944b6e5fe8dd535d6381b93d88bf4a854dac53d4/mona-lisa.jpg\";\n\n// Reference: https://observablehq.com/@mbostock/image-histogram/2\nfunction getImageData(image, width = image.naturalWidth, height = image.naturalHeight) {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    \n    const context = canvas.getContext(\"2d\");\n    context.drawImage(image, 0, 0, width, height);\n    const imageData = context.getImageData(0, 0, width, height).data;\n    return Uint8Array.from(imageData);\n}\n\nfunction getChannelData(imageData, offset = 0, float = false) {\n    const channelData = (float ? new Float32Array(imageData.length / 4) : new Uint8Array(imageData.length / 4));\n    for(let i = 0; i < channelData.length; i++) {\n      channelData[i] = imageData[i * 4 + offset];\n    }\n    return channelData;\n}\n\n\nnew Promise((resolve, reject) => {\n    const image = new Image;\n    image.onload = () => resolve(image);\n    image.onerror = reject;\n    image.crossOrigin = \"anonymous\";\n    image.src = imageUrl;\n}).then((image) => {\n    console.log(image);\n    // Get the image data Uint8ClampedArray from the image object.\n    const imageData = getImageData(image);\n    // Get the red channel.\n    const channelData = getChannelData(imageData, 0);\n    const rgbaPromise = createRgbaHistogram(imageData, image.naturalWidth, image.naturalHeight);\n    const singleChannelPromise = createSingleChannelHistogram(channelData, image.naturalWidth, image.naturalHeight);\n\n    return Promise.all([rgbaPromise, singleChannelPromise]);\n})\n.then(([rgbaHistogramData, singleChannelHistogramData]) => {\n    console.log(\"createRgbaHistogram\", rgbaHistogramData);\n    console.log(\"createSingleChannelHistogram\", singleChannelHistogramData);\n\n    const mlImage = document.createElement(\"img\");\n    mlImage.crossOrigin = true;\n    mlImage.src = imageUrl;\n    mlImage.width = 200;\n    document.querySelector(\"#root\").appendChild(mlImage);\n\n    const header = document.createElement(\"h2\");\n    header.innerHTML = \"histogram.gl results (left: RGB, right: single channel)\";\n    document.querySelector(\"#root\").appendChild(header);\n\n\n    const canvas = document.createElement(\"canvas\");\n    document.querySelector(\"#root\").appendChild(canvas);\n\n    const canvasWidth = 400;\n    const canvasHeight = 200;\n\n    canvas.width = canvasWidth * 2.5;\n    canvas.height = canvasHeight;\n\n    const ctx = canvas.getContext(\"2d\");\n    ctx.globalAlpha = 0.4;\n\n    const channels = [\"red\", \"green\", \"blue\"];\n\n    channels.forEach((channel, channelOffset) => {\n        const channelHistogramData = Array.from(getChannelData(rgbaHistogramData, channelOffset, true));\n        const channelHistogramMax = Math.max(...channelHistogramData);\n\n        channelHistogramData.forEach((d, i) => {\n            const height = (d / channelHistogramMax) * canvasHeight;\n            const x = i / 256 * canvasWidth;\n            ctx.beginPath();\n            ctx.rect(x, canvasHeight - height, 1 / 256 * canvasWidth, canvasHeight);\n            ctx.fillStyle = channel;\n            ctx.fill();\n        });\n    });\n\n    // Draw single-channel histogram data on same canvas\n    const singleChannelOffsetX = canvasWidth * 1.5;\n    const redHistogramData = Array.from(singleChannelHistogramData);\n    const redHistogramMax = Math.max(...redHistogramData);\n    redHistogramData.forEach((d, i) => {\n        const height = (d / redHistogramMax) * canvasHeight;\n        const x = i / 256 * canvasWidth;\n        ctx.beginPath();\n        ctx.rect(singleChannelOffsetX + x, canvasHeight - height, 1 / 256 * canvasWidth, canvasHeight);\n        ctx.fillStyle = \"red\";\n        ctx.fill();\n    });\n\n    const header2 = document.createElement(\"h2\");\n    header2.innerHTML = \"ground truth (macOS preview screenshot)\";\n    document.querySelector(\"#root\").appendChild(header2);\n\n    const gtImage = document.createElement(\"img\");\n    gtImage.crossOrigin = true;\n    gtImage.src = \"https://raw.githubusercontent.com/keller-mark/histogram.gl/master/screenshot.png\";\n    document.querySelector(\"#root\").appendChild(gtImage);\n});"],"names":["rgba","vs","fs","singleChannel","toFinite","value","range","start","end","step","undefined","fromRight","index","length","Math","max","ceil","result","Array","baseRange","createShader","gl","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","createHistogram","imageData","imageWidth","imageHeight","isRgba","Promise","resolve","reject","canvas","document","createElement","width","height","getContext","forEach","extName","getExtension","warn","pixelIds","Float32Array","from","imageTexture","createTexture","imageTextureFormat","RGBA","LUMINANCE","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","texImage2D","UNSIGNED_BYTE","shaderSources","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","pixelIdsBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","targetTexture","FLOAT","targetFramebuffer","createFramebuffer","bindFramebuffer","FRAMEBUFFER","attachmentPoint","COLOR_ATTACHMENT0","framebufferTexture2D","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","Error","blendEquation","FUNC_ADD","blendFunc","ONE","clearColor","disable","DEPTH_TEST","enable","BLEND","useProgram","pixelIdsAttributeLocation","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","viewport","clear","COLOR_BUFFER_BIT","unit","numChannels","channel","colorMask","resolutionLocation","getUniformLocation","uniform2fv","colorMultLocation","uniform4fv","imageTextureLocation","activeTexture","TEXTURE0","uniform1i","drawArrays","POINTS","flush","histogramData","TARGET_TEXTURE_WIDTH","readPixels","offset","channelData","i","getChannelData","imageUrl","float","Uint8Array","image","Image","onload","onerror","crossOrigin","src","then","rgbaData","naturalWidth","naturalHeight","context","drawImage","getImageData","data","rgbaPromise","singleChannelPromise","createSingleChannelHistogram","all","rgbaHistogramData","singleChannelHistogramData","mlImage","querySelector","appendChild","header","innerHTML","canvasWidth","ctx","globalAlpha","channelOffset","channelHistogramData","channelHistogramMax","d","x","beginPath","rect","fillStyle","fill","redHistogramData","redHistogramMax","header2","gtImage"],"mappings":"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"}